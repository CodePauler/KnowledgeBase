## 一、整体 ER 关系梳理（核心逻辑）

模型可以抽象成一句话：

> **用户 → 空间 → 知识 → 向量（RAG）**

### 1️⃣ 用户（user）

* **一个用户可以拥有多个知识库空间**
* `user.id` ← `space.user_id`

```text
user 1 ──── N space
```

用户是**权限和所有权的最外层边界**

---

### 2️⃣ 知识库空间（space）

空间是一个**逻辑知识库容器**，用于：

* 按项目 / 课程 / 研究方向 / 公司部门划分
* 作为 **RAG 检索与权限隔离的最小单元**

```text
space 1 ──── N knowledge
```

* `space.id` ← `knowledge.space_id`

---

### 3️⃣ 知识条目（knowledge）——核心表

这是**整个系统最关键的表**，它统一承载了：

| 类型         | 枚举值                 |
| ---------- | ------------------- |
| 文档类 · 非结构化 | `DOC_UNSTRUCTURED`  |
| 文档类 · 结构化  | `DOC_STRUCTURED`    |
| 人工录入 · 结构化 | `MANUAL_STRUCTURED` |

并通过字段组合区分 **“形态”** 而不是拆表。

#### ① 层级结构（知识树）

```sql
parent_id BIGINT
FOREIGN KEY (parent_id) REFERENCES knowledge(id)
```

支持：

* 目录 / 子目录
* FAQ → 子问题
* 手工结构化知识的**父子节点**

```text
knowledge (父)
   └── knowledge (子)
```

---

### 4️⃣ 知识向量表（knowledge_embedding）

```text
knowledge 1 ──── N knowledge_embedding
```

* 一个知识 → **多个文本 chunk**
* 每个 chunk → 一个 embedding

> 当前版本采用 MySQL 存储向量，向量相似度计算在应用层完成，适合中小规模知识库。当数据规模扩大时，可无缝迁移至 PostgreSQL + PGVector 或专用向量数据库，以提升检索性能。

---

## 二、三类知识在表结构中的落地方式

### 🔹 1. 文档类知识（非结构化）

**典型：PDF / Word / Markdown / PPT**

| 字段          | 用法                 |
| ----------- | ------------------ |
| `type`      | `DOC_UNSTRUCTURED` |
| `title`     | 文件名 / 文档标题         |
| `oss_key`   | 文件存储路径             |
| `content`   | ❌ 通常为空             |
| `parent_id` | 可选（放在某目录下）         |

**文本内容来自：**

* 文档解析后 → 切 chunk → 存 `knowledge_embedding.text_chunk`

---

### 🔹 2. 文档类知识（结构化）

**典型：章节型文档 / 标准文档**

| 字段          | 用法               |
| ----------- | ---------------- |
| `type`      | `DOC_STRUCTURED` |
| `title`     | 文档标题             |
| `oss_key`   | 原始文件             |
| `parent_id` | 章节结构             |
| `content`   | 可选（章节摘要）         |

结构示例：

```text
知识A（文档）
 ├── 知识A-1（第一章）
 ├── 知识A-2（第二章）
```

---

### 🔹 3. 人工录入类知识（结构化）

**典型：FAQ / 规章 / 知识卡片**

| 字段          | 用法                  |
| ----------- | ------------------- |
| `type`      | `MANUAL_STRUCTURED` |
| `title`     | 问题 / 概念             |
| `content`   | 手工输入正文              |
| `parent_id` | 分类                  |
| `oss_key`   | ❌ 为空                |


---

## 三、表间关系总结

| 表                     | 角色              |
| --------------------- | --------------- |
| `user`                | 所有权、权限主体        |
| `space`               | 知识隔离 + RAG 检索边界 |
| `knowledge`           | 统一知识抽象（文档 / 手工） |
| `knowledge_embedding` | RAG 向量存储        |

---

## 用户「上传 / 录入知识」时需要采集哪些字段？

---

### 场景 1：上传文档类知识（结构 / 非结构）

#### 前端需要采集

| 字段          | 必填 | 说明                                |
| ----------- | -- | --------------------------------- |
| `space_id`  | ✅  | 放入哪个知识库                           |
| `title`     | ✅  | 默认文件名                             |
| `type`      | ✅  | DOC_UNSTRUCTURED / DOC_STRUCTURED |
| `file`      | ✅  | 原始文件                              |
| `parent_id` | ❌  | 所属目录                              |

#### 后端需要存储

**knowledge 表**

```text
space_id
title
type
oss_key
parent_id
```

**knowledge_embedding 表（异步）**

```text
knowledge_id
text_chunk
embedding
```

---

### 场景 2：人工录入结构化知识

#### 前端需要采集

| 字段          | 必填 | 说明                |
| ----------- | -- | ----------------- |
| `space_id`  | ✅  | 知识库               |
| `title`     | ✅  | 问题 / 概念           |
| `content`   | ✅  | 正文                |
| `parent_id` | ❌  | 分类                |
| `type`      | 固定 | MANUAL_STRUCTURED |

#### 后端需要存储

**knowledge 表**

```text
space_id
title
content
type = MANUAL_STRUCTURED
parent_id
```

**knowledge_embedding 表**

```text
knowledge_id
text_chunk (content 切分)
embedding
```

### ✅ 优点

1. **统一抽象知识模型（knowledge）**

   - 不为不同来源拆表
2. **天然支持知识树**
3. **RAG 原生设计**
4. **空间即权限边界**
5. **文档 & 手工知识无缝融合**